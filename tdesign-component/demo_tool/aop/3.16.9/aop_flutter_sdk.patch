From 43b5ed78c9554704e54ca2568426666d216c0004 Mon Sep 17 00:00:00 2001
From: skylerpfli <skylerpfli@tencent.com>
Date: Tue, 21 Nov 2023 19:21:18 +0800
Subject: [PATCH] 1.0.8

---
 packages/flutter_tools/bin/flutter_tools.dart |    1 +
 .../interceptor/impl/compile_interceptor.dart |  186 +++
 .../interceptor/impl/pub_interceptor.dart     | 1031 +++++++++++++++++
 .../interceptor/interceptor_manager.dart      |   27 +
 .../interceptor/interface/interceptor.dart    |    5 +
 .../aop_tools/interceptor/utils/constant.dart |  108 ++
 .../interceptor/utils/package_utils.dart      |  413 +++++++
 .../lib/src/aop_tools/logger.dart             |   36 +
 .../lib/src/aop_tools/process_decorator.dart  |   65 ++
 .../flutter_tools/lib/src/base/context.dart   |    3 +-
 10 files changed, 1874 insertions(+), 1 deletion(-)
 create mode 100644 packages/flutter_tools/lib/src/aop_tools/interceptor/impl/compile_interceptor.dart
 create mode 100644 packages/flutter_tools/lib/src/aop_tools/interceptor/impl/pub_interceptor.dart
 create mode 100644 packages/flutter_tools/lib/src/aop_tools/interceptor/interceptor_manager.dart
 create mode 100644 packages/flutter_tools/lib/src/aop_tools/interceptor/interface/interceptor.dart
 create mode 100644 packages/flutter_tools/lib/src/aop_tools/interceptor/utils/constant.dart
 create mode 100644 packages/flutter_tools/lib/src/aop_tools/interceptor/utils/package_utils.dart
 create mode 100644 packages/flutter_tools/lib/src/aop_tools/logger.dart
 create mode 100644 packages/flutter_tools/lib/src/aop_tools/process_decorator.dart

diff --git a/packages/flutter_tools/bin/flutter_tools.dart b/packages/flutter_tools/bin/flutter_tools.dart
index 2caa134a35..eca6551ab6 100644
--- a/packages/flutter_tools/bin/flutter_tools.dart
+++ b/packages/flutter_tools/bin/flutter_tools.dart
@@ -5,5 +5,6 @@
 import 'package:flutter_tools/executable.dart' as executable;
 
 void main(List<String> args) {
+  print('AOPTools ====> flutter_tools execute: ${args.join(' ')}');
   executable.main(args);
 }
diff --git a/packages/flutter_tools/lib/src/aop_tools/interceptor/impl/compile_interceptor.dart b/packages/flutter_tools/lib/src/aop_tools/interceptor/impl/compile_interceptor.dart
new file mode 100644
index 0000000000..eb2ba1a18b
--- /dev/null
+++ b/packages/flutter_tools/lib/src/aop_tools/interceptor/impl/compile_interceptor.dart
@@ -0,0 +1,186 @@
+import 'dart:io';
+
+import 'package:path/path.dart';
+
+import '../../../convert.dart';
+import '../../../globals.dart' as globals;
+import '../../logger.dart';
+import '../../process_decorator.dart';
+import '../interface/interceptor.dart';
+import '../utils/constant.dart';
+import '../utils/package_utils.dart';
+
+abstract class CompileInterceptor implements IInterceptor {
+  static const String _tag = 'CompileInterceptor';
+
+  String getTargetSnapshot();
+
+  String getStarterFileName();
+
+  @override
+  bool isTargetCommand(List<Object> command) {
+    for (final Object obj in command) {
+      if (obj is String && obj.endsWith(getTargetSnapshot())) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  @override
+  Future<List<Object>> handle(String? _, Map<String, String>? environment, List<Object> command) async {
+    Logger.emptyLog();
+    int snapshotIndex = -1;
+    for (int index = 0; index < command.length; index++) {
+      final Object obj = command[index];
+      if (obj is String && obj.endsWith(getTargetSnapshot())) {
+        snapshotIndex = index;
+      }
+    }
+
+    if (snapshotIndex < 0) {
+      return command;
+    }
+
+    // 检查是否有插桩工程
+    final Directory workingDirectory = globals.fs.currentDirectory;
+
+    final List<String> aopProjects = (await fetchAOPProject(workingDirectory.absolute.path, isPub: false)).values.map((final Directory e) => normalize(e.absolute.path)).toList();
+    if (aopProjects.isEmpty) {
+      return command;
+    }
+
+    final Directory marketDirectory = fetchAOPMarket(command.first as String);
+    final File marketYamlFile = File(join(marketDirectory.path, yamlName));
+    final File projectFile = File(join(marketDirectory.path, projectFileName)); // 工程AOP信息
+    final File starterFile = File(join(marketDirectory.path, libDir, getStarterFileName())); // 入口文件
+
+    if (!marketYamlFile.existsSync() || !projectFile.existsSync() || !starterFile.existsSync()) {
+      // 尝试先pub get
+      await runPubGet(command.first as String);
+    }
+
+    if (!marketYamlFile.existsSync()) {
+      throw AOPError('AOPMarket未配置，请pub get/upgrade后重试!');
+    }
+
+    if (!projectFile.existsSync() || !starterFile.existsSync()) {
+      throw AOPError('AOP依赖未配置，请pub get/upgrade后重试!');
+    }
+
+    Map<dynamic, dynamic>? projectRecord;
+    List<String> recordAOPProjects;
+    try {
+      projectRecord = jsonDecode(projectFile.readAsStringSync(encoding: utf8)) as Map<dynamic, dynamic>;
+      recordAOPProjects = (projectRecord[projectConfigAopProjects] as String).split(projectConfigSeparator);
+    } on Exception catch (e) {
+      throw AOPError('未知错误，工程配置解析异常，配置: ${projectFile.absolute.path}, error: $e');
+    }
+
+    if (projectRecord[projectConfigDart] != dartVersion || projectRecord[projectConfigDir] != workingDirectory.absolute.path || !_compareList(aopProjects, recordAOPProjects)) {
+      // 尝试先pub get
+      await runPubGet(command.first as String);
+
+      // 再重新读取文件
+      try {
+        projectRecord = jsonDecode(projectFile.readAsStringSync(encoding: utf8)) as Map<dynamic, dynamic>;
+        recordAOPProjects = (projectRecord[projectConfigAopProjects] as String).split(projectConfigSeparator);
+      } on Exception catch (e) {
+        throw AOPError('未知错误，工程配置解析异常，配置: ${projectFile.absolute.path}, error: $e');
+      }
+    }
+
+    if (projectRecord[projectConfigDart] != dartVersion) {
+      throw AOPError('dart版本错误，请pub get/upgrade后重试，old: ${projectRecord[projectConfigDart]}, now: $dartVersion');
+    }
+
+    if (projectRecord[projectConfigDir] != workingDirectory.absolute.path) {
+      throw AOPError('AOP依赖须重新配置，请pub get/upgrade后重试!');
+    }
+
+    if (!_compareList(aopProjects, recordAOPProjects)) {
+      throw AOPError('关联的AOP工程发生变化，请pub get/upgrade后重试!');
+    }
+
+    final File snapshotFile = File(join(marketDirectory.path, libDir, getTargetSnapshot()));
+    if (snapshotFile.existsSync()) {
+      snapshotFile.deleteSync();
+    }
+
+    final List<String> commands = <String>[
+      command.first as String, // dart路径
+      '--deterministic',
+      '--packages=${join(marketDirectory.absolute.path, dartTool, packageConfig)}',
+      '--snapshot=${snapshotFile.path}',
+      '--snapshot-kind=kernel',
+      starterFile.absolute.path,
+      ProcessDecorator.skipInterceptCommand,
+    ];
+    final ProcessResult processResult = globals.processManager.runSync(commands);
+
+    if (processResult.exitCode != processResultOK || !snapshotFile.existsSync()) {
+      throw AOPError('AOP snapshot编译失败，请检查插桩代码并尝试pub get/upgrade。error: ${processResult.stderr}');
+    }
+
+    // 替换snapshot
+    command[snapshotIndex] = snapshotFile.absolute.path;
+
+    Logger.d('AOP ${getTargetSnapshot()} start: ${command.join(' ')}\n', tag: _tag);
+
+    // 热重启、recompile时也会走到此处，仅带main.dart入口的编译是可AOP调试的
+    if (command.last is String && (command.last as String).endsWith('.dart')) {
+      print('''
+---------------------------------
+AOP调试信息, Dart Command Line App
+
+* DartFile: ${starterFile.path}
+
+* Program arguments: ${command.sublist(snapshotIndex + 1).join(' ')}
+
+* Working directory: ${normalize(workingDirectory.absolute.path)}
+
+''');
+    }
+
+    return command;
+  }
+
+  Future<bool> runPubGet(String dartPath) async {
+    print('Running "flutter pub get" in ${globals.fs.currentDirectory.basename}...');
+    final List<String> pubCommand = compareVersions(flutterVersion, '2.8.0') >= 0 ? <String>[dartPath, '__deprecated_pub'] : <String>[join(File(dartPath).parent.path, 'pub')];
+    final ProcessResult processResult = await globals.processManager.run(<Object>[...pubCommand, pubCommandGet], workingDirectory: globals.fs.currentDirectory.path);
+    print('${processResult.stderr}');
+    return processResult.exitCode == processResultOK;
+  }
+
+  // 比较两个集合的元素完全相等
+  bool _compareList(List<dynamic> a, List<dynamic> b) {
+    a = <dynamic>[...a];
+    b = <dynamic>[...b];
+    for (dynamic aItem in a) {
+      if (!b.remove(aItem)) {
+        return false;
+      }
+    }
+
+    return b.isEmpty;
+  }
+}
+
+// Android/iOS
+class FrontendServerInterceptor extends CompileInterceptor {
+  @override
+  String getStarterFileName() => staterFileName;
+
+  @override
+  String getTargetSnapshot() => frontendServerSnapshot;
+}
+
+// web
+class Dart2JsInterceptor extends CompileInterceptor {
+  @override
+  String getStarterFileName() => dart2JsStaterFileName;
+
+  @override
+  String getTargetSnapshot() => dart2jsSnapshot;
+}
diff --git a/packages/flutter_tools/lib/src/aop_tools/interceptor/impl/pub_interceptor.dart b/packages/flutter_tools/lib/src/aop_tools/interceptor/impl/pub_interceptor.dart
new file mode 100644
index 0000000000..1422414c97
--- /dev/null
+++ b/packages/flutter_tools/lib/src/aop_tools/interceptor/impl/pub_interceptor.dart
@@ -0,0 +1,1031 @@
+import 'dart:convert';
+import 'dart:io';
+
+import 'package:crypto/crypto.dart';
+import 'package:package_config/package_config.dart';
+import 'package:path/path.dart';
+import 'package:yaml/yaml.dart';
+
+import '../../../globals.dart' as globals;
+import '../../logger.dart';
+import '../../process_decorator.dart';
+import '../interface/interceptor.dart';
+import '../utils/constant.dart';
+import '../utils/package_utils.dart';
+
+// pub get
+class PubInterceptor implements IInterceptor {
+  static const String _tag = 'PubInterceptor';
+
+  //当前pub命令
+  List<String> _currentPubCommand = <String>[];
+
+  dynamic marketVersion;
+
+  @override
+  bool isTargetCommand(List<Object> command) {
+    if (command.length < pubCommandMinLength || !command.contains(pubCommandGet) && !command.contains(pubCommandUpgrade) || command.contains(pubHelp)) {
+      return false;
+    }
+
+    if (command[0] is String && (command[0] as String).endsWith(pubCommandStart)) {
+      _currentPubCommand = <String>[command[0] as String];
+    } else if (command[0] is String && (command[0] as String).endsWith(pubCommandStartV2) && command[1] is String && (command[1] as String).endsWith(pubCommandStart)) {
+      _currentPubCommand = <String>[command[0] as String, command[1] as String];
+    } else {
+      return false;
+    }
+
+    return true;
+  }
+
+  // pub get/upgrade
+
+  /// ！核心逻辑链
+  @override
+  Future<List<Object>> handle(String? workingDirectory, Map<String, String>? environment, List<Object> command) async {
+    final int startTime = DateTime.now().millisecondsSinceEpoch;
+    Logger.emptyLog();
+
+    workingDirectory ??= globals.fs.currentDirectory.absolute.path;
+
+    // 获取所有AOP工程：i.主工程下有AOPTools; ii.依赖工程设有AOPMarket配置。
+    final Map<String, Directory> aopProjects = await _fetchAOPProject(workingDirectory, environment, command);
+    if (aopProjects.isEmpty) {
+      return command;
+    }
+    Logger.d('发现AOP工程: $aopProjects ', tag: _tag);
+
+    // 获取依赖的AOPMarket工程
+    final Directory aopMarketProject = _fetchAOPMarket(command.first as String, aopProjects, workingDirectory);
+
+    Logger.d('当前AOPMarketVersion: $marketVersion, patchVersion: $patchVersion', tag: _tag);
+    Logger.d('第一次pub get/upgrade可能需要几分钟的时间....', tag: _tag);
+
+    // 解析配置
+    final Map<dynamic, dynamic>? dartConfigs = _parseDartConfig(aopMarketProject);
+    if (dartConfigs == null) {
+      Logger.e('AOPMarket不支持当前dart版本，请联系开发团队适配', tag: _tag);
+      return command;
+    }
+
+    // 获取dart工程: 在AOPMarket yaml文件中写入dart对应版本的依赖，pub upgrade以获取，通过补丁、脚本修改dart，并提交
+    final Directory dartProject = await _fetchDartProject(aopMarketProject, workingDirectory, dartConfigs);
+
+    // 配置各工程AOP环境：通过dart DEPS以及AOPMarket配置文件，生成新的AOP工程的yaml文件，AOPMarket的yaml文件(含AOP工程依赖)，并且pub upgrade
+    await _handleDependencies(aopProjects, aopMarketProject, dartProject, dartConfigs);
+
+    // AOPMarket生成main.dart，main_web.dart入口，注入初始化函数。
+    _generateStarterEntry(aopProjects, aopMarketProject, workingDirectory);
+
+    Logger.d('完成AOP依赖处理，用时: ${DateTime.now().millisecondsSinceEpoch - startTime}ms\n', tag: _tag);
+    return command;
+  }
+
+  /// ① 获取所有AOP工程
+  Future<Map<String, Directory>> _fetchAOPProject(String workingDirectory, Map<String, String>? environment, List<Object> pubCommands) async {
+    // 先执行完pub
+    final ProcessResult processResult = globals.processManager.runSync(pubCommands, workingDirectory: workingDirectory, environment: environment);
+    if (processResult.exitCode != processResultOK) {
+      Logger.w('工程pub操作失败，error: ${processResult.stderr}\n', tag: _tag);
+      return <String, Directory>{};
+    }
+
+    return fetchAOPProject(workingDirectory);
+  }
+
+  /// ② 获取AOPMarket工程
+  Directory _fetchAOPMarket(String commandPath, Map<String, Directory> aopProjects, String workPath) {
+    final Directory aopMarketProject = fetchAOPMarket(commandPath);
+    final File recordFile = File(join(aopMarketProject.path, projectFileName));
+
+    if (!File(join(aopMarketProject.path, yamlName)).existsSync()) {
+      // git clone
+      if (aopMarketProject.existsSync()) {
+        aopMarketProject.deleteSync(recursive: true);
+      }
+
+      _runGit(aopMarketProject.parent.absolute.path, gitCloneMarket, '_fetchAOPMarket git clone error');
+    } else {
+      // 切换工程的依赖清空在_fetchDartProject中进行
+
+      // 保留缓存，更新
+      final bool gitSuccess = _runGit(aopMarketProject.parent.absolute.path, gitPull, '_fetchAOPMarket git pull error', throwError: false);
+
+      // 更新
+      if (!gitSuccess) {
+        _runGit(aopMarketProject.parent.absolute.path, gitAdd, '_fetchAOPMarket git add error');
+        _runGit(aopMarketProject.parent.absolute.path, gitStash, '_fetchAOPMarket git stash error');
+        _runGit(aopMarketProject.parent.absolute.path, gitStashClear, '_fetchAOPMarket git stash clear error');
+        _runGit(aopMarketProject.parent.absolute.path, gitPull, '_fetchAOPMarket git pull2 error');
+      }
+    }
+
+    // 清除AOPMarket工程配置
+    if (recordFile.existsSync()) {
+      File(join(aopMarketProject.path, projectFileName)).deleteSync();
+    }
+
+    final File yamlFile = File(join(aopMarketProject.path, yamlName));
+    if (yamlFile.existsSync()) {
+      final YamlMap yamlConfigs = loadYamlNode(yamlFile.readAsStringSync(encoding: utf8)) as YamlMap;
+      marketVersion = yamlConfigs[yamlProjectVersion];
+    } else {
+      Logger.e('未知错误，AOPMarket的$yamlName不存在', tag: _tag);
+    }
+
+    return aopMarketProject;
+  }
+
+  /// ③ 解析dart依赖配置
+  Map<dynamic, dynamic>? _parseDartConfig(Directory aopMarketProject) {
+    final File dartConfigFile = File(join(aopMarketProject.path, dartPatchDir, dartConfigName));
+    if (!dartConfigFile.existsSync()) {
+      throw AOPError('未知错误，dartConfig不存在: ${dartConfigFile.path}');
+    }
+
+    Map<dynamic, dynamic>? result;
+    final Map<dynamic, dynamic> configs = jsonDecode(dartConfigFile.readAsStringSync(encoding: utf8)) as Map<dynamic, dynamic>;
+    configs.forEach((dynamic key, dynamic value) {
+      if (key is! String) {
+        return;
+      }
+
+      final List<String> versions = key.replaceAll(' ', '').split(versionSeparator).toList();
+      String startVersion;
+      String endVersion;
+      if (versions.length == 1) {
+        startVersion = versions[0];
+        endVersion = versions[0];
+      } else if (versions.length == 2) {
+        startVersion = versions[0];
+        endVersion = versions[1];
+      } else {
+        throw AOPError('未知错误，dartConfig异常，版本范围异常');
+      }
+
+      if ((compareVersions(dartVersion, startVersion) >= 0) && (compareVersions(endVersion, dartVersion) > 0)) {
+        if (result != null) {
+          Logger.w('dartConfigs有多个AOP匹配版本，屏蔽版本: $key', tag: _tag);
+          return;
+        }
+
+        result = value as Map<dynamic, dynamic>;
+        if (result![dartConfigPatch] is! String || result![dartConfigShell] is! String || result![dartConfigDeps] == null) {
+          throw AOPError('dartConfigs配置信息异常，dart版本：$dartVersion, 配置文件: ${dartConfigFile.path}');
+        }
+      }
+    });
+
+    return result;
+  }
+
+  /// ④ 获取dart工程
+  Future<Directory> _fetchDartProject(Directory aopMarketProject, String? workingDirectory, Map<dynamic, dynamic> dartConfigs, {bool isRetry = false}) async {
+    final File dartPatchFile = File(normalize(absolute(aopMarketProject.path, dartConfigs[dartConfigPatch] as String)));
+    final File dartShellFile = File(normalize(absolute(aopMarketProject.path, dartConfigs[dartConfigShell] as String)));
+
+    if (!dartPatchFile.existsSync() || !dartShellFile.existsSync()) {
+      throw AOPError('未知错误，dart改造文件不存在, dartPatchFile: $dartPatchFile, dartShellFile: $dartShellFile');
+    }
+
+    // dart处理完成的commit
+    final String newCommit = _createDartCommit(dartPatchFile: dartPatchFile, dartShellFile: dartShellFile);
+
+    // 检查dart commit是否一致，满足条件
+    bool checkDart(Directory dartProject) {
+      // 形如 a58541463f6 \"AOPTools ====> Dart2.19.6 patchDart730b5cefbee3e779c6a8b1bf78bfd1d2 shell1d8483d19f5230de31837d9adfa46db4\"
+      String lastCommit = globals.processManager.runSync(gitShowLastLog.split(' '), workingDirectory: dartProject.path).stdout as String;
+      final List<String> lastCommitList = lastCommit.split('"');
+      if (lastCommitList.length > 2) {
+        lastCommit = lastCommitList[1];
+      }
+
+      // 使用缓存，无需改造
+      return lastCommit == newCommit;
+    }
+
+    // 先尝试从缓存中获取，优化pub耗时
+    final PackageConfig packageConfig = await parsePackages(aopMarketProject.path, ignoreError: true);
+    for (final Package package in packageConfig.packages) {
+      if (package.name == kernelPackage) {
+        final Directory dartProject = Directory(Uri.decodeComponent(package.root.path)).parent.parent;
+        if (dartProject.existsSync() && checkDart(dartProject)) {
+          return dartProject;
+        }
+      }
+    }
+
+    final AOPYamlConfig aopMarketConfig = AOPYamlConfig(File(join(aopMarketProject.path, yamlName)));
+    if (aopMarketConfig.writeMarketKernelDependency(dependencyConfiguration: DependencyConfiguration.dependency_overrides)) {
+      // 获取dart工程依赖
+      final ProcessResult processResult = globals.processManager.runSync(<Object>[..._currentPubCommand, pubCommandGet, ProcessDecorator.skipInterceptCommand], workingDirectory: aopMarketProject.path);
+      if (processResult.exitCode != processResultOK &&
+          // 重试...
+          !retryWriteMarketDependencies(aopMarketProject, () {
+            aopMarketConfig.writeMarketKernelDependency(dependencyConfiguration: DependencyConfiguration.dependency_overrides);
+            return globals.processManager.runSync(<Object>[..._currentPubCommand, pubCommandGet, ProcessDecorator.skipInterceptCommand], workingDirectory: aopMarketProject.path).exitCode == processResultOK;
+          })) {
+        throw AOPError('请flutter clean后重试，获取aopMarket工程的dart依赖失败 error: ${processResult.stderr}');
+      }
+
+      final PackageConfig packageConfig = await parsePackages(aopMarketProject.path);
+      for (final Package package in packageConfig.packages) {
+        if (package.name == kernelPackage) {
+          final Directory dartProject = Directory(Uri.decodeComponent(package.root.path)).parent.parent;
+          if (!dartProject.existsSync()) {
+            throw AOPError('获取dart工程失败！');
+          }
+
+          if (checkDart(dartProject)) {
+            return dartProject;
+          }
+
+          // 重新处理Dart，加入hook代码
+
+          try {
+            // 切换到对应版本
+            _runGit(dartProject.absolute.path, gitAdd, '_fetchDartProject git add error');
+            _runGit(dartProject.absolute.path, gitStash, '_fetchDartProject git stash error');
+            _runGit(dartProject.absolute.path, gitStashClear, '_fetchDartProject git stash clear error');
+            _runGit(dartProject.absolute.path, gitFetch, '_fetchDartProject git fetch error');
+            _runGit(dartProject.absolute.path, '$gitResetHard $dartVersion', '_fetchDartProject git reset --hard error');
+
+            // 打入补丁
+            _runGit(dartProject.absolute.path, '$gitApplyPatch ${dartPatchFile.absolute.path}', '_fetchDartProject git apply patch error');
+            _runGitByList(dartProject.absolute.path, <String>[dartShellFile.path, join(dartProject.path, kernelTargetPath)], '_fetchDartProject run dartShellFile error');
+
+            // 提交
+            _runGit(dartProject.absolute.path, gitAdd, '_fetchDartProject git add 2 error');
+            _runGitByList(dartProject.absolute.path, <String>[...gitCommit.split(' '), '-m"$newCommit"'], '_fetchDartProject git add 2 error');
+          } on AOPError catch (e) {
+            if (isRetry) {
+              rethrow;
+            }
+
+            dartProject.deleteSync(recursive: true);
+            return _fetchDartProject(aopMarketProject, workingDirectory, dartConfigs, isRetry: true);
+          }
+
+          return dartProject;
+        }
+      }
+    } else {
+      throw AOPError('$pluginAopMarket写入dart依赖失败');
+    }
+
+    throw AOPError('获取dart工程失败！');
+  }
+
+  // 运行命令，异常抛出
+  bool _runGit(String projectPath, String command, String errorTips, {bool throwError = true}) {
+    return _runGitByList(projectPath, command.split(' '), errorTips, throwError: throwError);
+  }
+
+  bool _runGitByList(String projectPath, List<String> command, String errorTips, {bool throwError = true}) {
+    final ProcessResult processResult = globals.processManager.runSync(command, workingDirectory: projectPath);
+    if (exitCode == processResultOK) {
+      return true;
+    }
+
+    if (throwError) {
+      throw AOPError('$errorTips: ${processResult.stderr}');
+    }
+
+    Logger.e('$errorTips: ${processResult.stderr}', tag: _tag);
+    return false;
+  }
+
+  // 重新尝试写入AOPMarket依赖
+  bool retryWriteMarketDependencies(Directory aopMarketProject, bool Function() writeDependencies) {
+    Logger.d('AOPMarket依赖处理失败，请耐心等待，正在清除pub cache后重试...', tag: _tag);
+
+    // 清空AOPMarket代码
+    _runGit(aopMarketProject.absolute.path, gitAdd, 'retryWriteMarketDependencies git add error', throwError: false);
+    _runGit(aopMarketProject.absolute.path, gitStash, 'retryWriteMarketDependencies git stash error', throwError: false);
+    _runGit(aopMarketProject.absolute.path, gitStashClear, 'retryWriteMarketDependencies git stash clear error', throwError: false);
+    _runGit(aopMarketProject.absolute.path, gitPull, 'retryWriteMarketDependencies git pull error', throwError: false);
+
+    // 清空后pub get，清理缓存
+    if (globals.processManager.runSync(<Object>[..._currentPubCommand, pubCommandGet, ProcessDecorator.skipInterceptCommand], workingDirectory: aopMarketProject.path).exitCode != processResultOK) {
+      return false;
+    }
+
+    // 再次执行pub操作
+    return writeDependencies.call();
+  }
+
+  /// ⑤ 处理各项AOP工程依赖
+  Future<void> _handleDependencies(Map<String, Directory> aopProjects, Directory aopMarketProject, Directory dartProject, Map<dynamic, dynamic> dartConfigs) async {
+    final File DEPSFile = File(join(dartProject.path, dartDEPS));
+    if (!DEPSFile.existsSync()) {
+      throw AOPError('未知错误，DEPS文件不存在: ${DEPSFile.path}');
+    }
+
+    final String depsFileStr = DEPSFile.readAsStringSync(encoding: utf8);
+
+    // 变量定义的字符串，匹配如vars = {...}
+    final Iterable<RegExpMatch> varsIterable = RegExp(r'(?<=\nvars = {\n)[\s\S]*?(?=\n})').allMatches(depsFileStr);
+    if (varsIterable.isEmpty) {
+      throw AOPError('未知错误，DEPS文件未匹配到vars变量，DEPS: ${DEPSFile.path}');
+    }
+    if (varsIterable.length != 1) {
+      throw AOPError('未知错误，DEPS文件未匹配到多个vars变量，DEPS: ${DEPSFile.path}');
+    }
+
+    // 依赖字符串，匹配如deps = {...}
+    final Iterable<RegExpMatch> depsIterable = RegExp(r'(?<=\ndeps = {\n)[\s\S]*?(?=\n})').allMatches(depsFileStr);
+    if (depsIterable.isEmpty) {
+      throw AOPError('未知错误，DEPS文件未匹配到deps集合，DEPS: ${DEPSFile.path}');
+    }
+    if (varsIterable.length != 1) {
+      throw AOPError('未知错误，DEPS文件未匹配到多个deps集合，DEPS: ${DEPSFile.path}');
+    }
+
+    final String varsStr = depsFileStr.substring(varsIterable.first.start, varsIterable.first.end).replaceAll(' ', '');
+    final String depsStr = depsFileStr.substring(depsIterable.first.start, depsIterable.first.end);
+
+    // 解析变量值，匹配如"dart_root": "sdk",
+    final List<String> varsList = RegExp('(?<=").*?":".*?(?=",)').allMatches(varsStr).map((RegExpMatch e) => varsStr.substring(e.start, e.end)).toList();
+    final Map<String, String> vars = Map<String, String>.fromEntries(varsList.map((String e) {
+      final List<String> keyValue = e.split('":"');
+      if (keyValue.length != 2) {
+        throw AOPError('未知错误，DEPS文件中变量定义异常，变量：$e, DPS: ${DEPSFile.path}');
+      }
+      return MapEntry<String, String>(keyValue[0], keyValue[1]);
+    }));
+
+    // 解析依赖，匹配如// Var("dart_root") + "/third_party/pkg/args":...,
+    final List<String> rawGitDepsList = RegExp(r'(?<="/third_party/pkg_tested/).*?":[\s\S]*?(?=,)|(?<="/third_party/pkg/).*?":[\s\S]*?(?=,)').allMatches(depsStr).map((RegExpMatch e) => depsStr.substring(e.start, e.end)).toList();
+    // 变量替换
+    final List<String> gitDeps = rawGitDepsList.map((String rawDeps) {
+      return rawDeps.replaceAllMapped(RegExp(r'Var\(".*?"\)'), (Match match) {
+        final String variableStr = rawDeps.substring(match.start, match.end);
+        final String variable = variableStr.replaceRange(variableStr.length - 2, variableStr.length, '').replaceRange(0, 5, ''); // 去除Var(" 、 ")
+        final String? value = vars[variable];
+        if (value == null) {
+          throw '未知错误, 未找到变量：$variable,  DPS: ${DEPSFile.path}';
+        }
+        return value;
+      });
+    }).toList();
+
+    // 生成最终依赖
+    final List<YamlDependencies> gitDependencies = <YamlDependencies>[];
+
+    // 遍历文件夹，加入dart/pkg中依赖
+    final Directory pkgDirectory = Directory(join(dartProject.path, dartPkg));
+    if (!pkgDirectory.existsSync()) {
+      throw AOPError('未知错误，pkg文件夹不存在: ${pkgDirectory.path}');
+    }
+    pkgDirectory.listSync().forEach((final FileSystemEntity element) {
+      if (Directory(join(element.path, libDir)).existsSync()) {
+        gitDependencies.add(YamlDependencies(<String, Map<String, Map<String, String>>>{
+          basename(element.path): <String, Map<String, String>>{
+            YamlDependencies.yamlGit: <String, String>{
+              YamlDependencies.yamlUrl: dartGitUrl,
+              YamlDependencies.yamlRef: dartVersion,
+              YamlDependencies.yamlPath: join(dartPkg, basename(element.path)),
+              YamlDependencies.yamlDartGenerate: dartVersion,
+            }
+          }
+        }));
+      }
+    });
+
+    try {
+      // 配置文件，见AOPMarket工程dart_config.json文件
+      final Map<dynamic, dynamic> depsChanged = (dartConfigs[dartConfigDeps]?[dartConfigDepsChanged] ?? <dynamic, dynamic>{}) as Map<dynamic, dynamic>;
+      final List<dynamic> depsExcludes = (dartConfigs[dartConfigDeps]?[dartConfigDepsExcludes] ?? <dynamic>[]) as List<dynamic>;
+
+      // 解析DEPS
+      gitDeps.forEach((String e) {
+        final List<String> keyValue = e.split('":');
+        if (keyValue.length != 2 && keyValue.length != 3) {
+          throw AOPError('未知错误，DEPS文件中依赖定义异常，依赖：$e, DPS: ${DEPSFile.path}');
+        }
+
+        final List<YamlDependencies> result = <YamlDependencies>[];
+        final String rawPackage = keyValue[0].replaceAll(' ', '').replaceAll('"', '').replaceAll('+', '').replaceAll('\n', '');
+        final List<String> urlRefList = keyValue.last.replaceAll(' ', '').replaceAll('"', '').replaceAll('+', '').replaceAll('\n', '').split('@');
+        String url = urlRefList.first;
+        if (url.endsWith('/')) {
+          // 有时会在git链接后拼接/
+          url = url.substring(0, url.length - 1);
+        }
+        final String? ref = urlRefList.length > 1 ? urlRefList.last : null;
+
+        final List<dynamic>? changedConfigs = depsChanged[url] as List<dynamic>?;
+        if (changedConfigs != null) {
+          // 使用配置确定
+          changedConfigs.forEach((dynamic element) {
+            final String? useRef = (element[dartConfigRef] ?? ref) as String?;
+            final String? usePath = element[dartConfigPath] as String?;
+            result.add(YamlDependencies(<String, Map<String, Map<String, String>>>{
+              element[dartConfigPackage] as String: <String, Map<String, String>>{
+                YamlDependencies.yamlGit: <String, String>{
+                  YamlDependencies.yamlUrl: url,
+                  ...usePath == null ? <String, String>{} : <String, String>{YamlDependencies.yamlPath: usePath},
+                  ...useRef == null ? <String, String>{} : <String, String>{YamlDependencies.yamlRef: useRef},
+                  YamlDependencies.yamlDartGenerate: dartVersion,
+                }
+              }
+            }));
+          });
+        } else {
+          // 默认
+          result.add(YamlDependencies(<String, Map<String, Map<String, String>>>{
+            rawPackage: <String, Map<String, String>>{
+              YamlDependencies.yamlGit: <String, String>{
+                YamlDependencies.yamlUrl: url,
+                ...ref == null ? <String, String>{} : <String, String>{YamlDependencies.yamlRef: ref},
+                YamlDependencies.yamlDartGenerate: dartVersion,
+              }
+            }
+          }));
+        }
+
+        gitDependencies.addAll(result);
+      });
+
+      // 排除
+      gitDependencies.removeWhere((YamlDependencies element) => depsExcludes.contains(element.get().keys.first));
+    } on Exception catch (e) {
+      throw AOPError('未知错误，处理依赖失败，可能是配置异常，error：$e');
+    }
+
+    final Map<String, YamlDependencies> devDependencies = <String, YamlDependencies>{}; // AOP dev总集
+    final Map<String, YamlDependencies> overrideDependencies = <String, YamlDependencies>{}; // AOP dev总集
+
+    // 收集不可传递的依赖，用于写入AOPMarket
+    <String, Directory>{...aopProjects}.forEach((final String package, final Directory element) {
+      final AOPYamlConfig elementConfig = AOPYamlConfig(File(join(element.path, yamlName)));
+      final Map<DependencyConfiguration, YamlDependencies> otherDependencies = elementConfig.fetchOtherDependencies();
+      if (otherDependencies[DependencyConfiguration.dev_dependencies] != null) {
+        devDependencies[package] = otherDependencies[DependencyConfiguration.dev_dependencies]!;
+      }
+      if (otherDependencies[DependencyConfiguration.dependency_overrides] != null) {
+        overrideDependencies[package] = otherDependencies[DependencyConfiguration.dependency_overrides]!;
+      }
+    });
+
+    // 处理AOPMarket的依赖
+    final List<YamlDependencies> localDependencies = <YamlDependencies>[];
+    aopProjects.forEach((final String package, final Directory element) {
+      localDependencies.add(YamlDependencies(<String, Map<String, String>>{
+        package: <String, String>{YamlDependencies.yamlPath: element.path}
+      }, type: DependenciesType.local));
+    });
+    final YamlDependencies aopMarketDependencies = YamlDependencies.merge(<YamlDependencies>[...localDependencies, ...gitDependencies]);
+    final AOPYamlConfig marketConfig = AOPYamlConfig(File(join(aopMarketProject.path, yamlName)));
+
+    final Map<DependencyConfiguration, YamlDependencies> totalDependencies = {
+      DependencyConfiguration.dependency_overrides: YamlDependencies.conflictMerge(
+        <String, YamlDependencies>{
+          ...overrideDependencies,
+          ...<String, YamlDependencies>{pluginAopMarket: aopMarketDependencies}
+        },
+      )
+    };
+
+    if (devDependencies.isNotEmpty) {
+      totalDependencies[DependencyConfiguration.dev_dependencies] = YamlDependencies.conflictMerge(devDependencies);
+    }
+
+    marketConfig.writeCommonDependencies(totalDependencies, clearRawDependencies: true);
+
+    final ProcessResult processResult = globals.processManager.runSync(<Object>[..._currentPubCommand, pubCommandGet, ProcessDecorator.skipInterceptCommand], workingDirectory: aopMarketProject.path);
+    if (processResult.exitCode != processResultOK &&
+        // 重试...
+        !retryWriteMarketDependencies(aopMarketProject, () {
+          marketConfig.writeCommonDependencies(totalDependencies, clearRawDependencies: true);
+          return globals.processManager.runSync(<Object>[..._currentPubCommand, pubCommandGet, ProcessDecorator.skipInterceptCommand], workingDirectory: aopMarketProject.path).exitCode == processResultOK;
+        })) {
+      throw AOPError('AOPMarket依赖处理异常，AOPMarket: ${aopMarketProject.path}, error: ${processResult.stderr}\n 若非依赖问题，可删除FlutterSDK/bin/cache目录后重试！');
+    }
+
+    // 处理AOP工程的依赖
+    YamlDependencies aopDependencies;
+    if (ProjectConfigExt.saveDartDependencies) {
+      // saveDart为git依赖才有意义
+      aopDependencies = YamlDependencies.merge(gitDependencies);
+    } else {
+      // 不save的情况使用本地依赖节省时间
+      final Map<String, Package> packages = <String, Package>{};
+      (await parsePackages(aopMarketProject.path)).packages.forEach((final Package package) {
+        packages[package.name] = package;
+      });
+      try {
+        aopDependencies = YamlDependencies.merge(gitDependencies.map((final YamlDependencies gitDependencies) {
+          final Map<String, dynamic> gitDependenciesValue = gitDependencies.get();
+          if (gitDependenciesValue.isEmpty) {
+            throw AOPError('未知错误，处理AOP工程依赖发生异常。');
+          }
+          final String packageName = gitDependencies.get().keys.first;
+          final Package? package = packages[packageName];
+          if (package == null) {
+            throw AOPError('未找到对应本地依赖，packageName: $packageName');
+          }
+          return YamlDependencies(<String, Map<String, String>>{
+            packageName: <String, String>{YamlDependencies.yamlPath: package.root.path}
+          }, type: DependenciesType.local);
+        }));
+      } on AOPError catch (e) {
+        Logger.w('AOP工程本地依赖处理异常，已切换为git依赖。原因: $e');
+        aopDependencies = YamlDependencies.merge(gitDependencies);
+      }
+    }
+    <String, Directory>{...aopProjects}
+      ..removeWhere((String key, Directory element) => !element.inMainProject() /*主工程目录引用才有必要配置依赖，插件不会直接引用*/)
+      ..forEach((final String package, final Directory element) {
+        final AOPYamlConfig elementConfig = AOPYamlConfig(File(join(element.path, yamlName)));
+
+        // 写入依赖
+        elementConfig.writeDependencies(aopDependencies, dependencyConfiguration: DependencyConfiguration.dependency_overrides, saveRawYaml: !ProjectConfigExt.saveDartDependencies);
+        final ProcessResult processResult = globals.processManager.runSync(<Object>[..._currentPubCommand, pubCommandGet, ProcessDecorator.skipInterceptCommand], workingDirectory: element.path);
+        !ProjectConfigExt.saveDartDependencies && elementConfig.recoverYaml();
+        if (processResult.exitCode != processResultOK) {
+          Logger.w('依赖处理错误，请检查yaml文件: ${join(element.path, yamlName)}。\n此错误不影响AOP整体运行，异议请联系AOPMarket开发团队！error：${processResult.stderr}\n错误工程: ${element.path}', tag: _tag);
+        }
+      });
+  }
+
+  /// ⑥ 生成AOP的入口文件
+  void _generateStarterEntry(Map<String, Directory> aopProjects, Directory aopMarketProject, String workPath) {
+    final Map<String, Directory> frontendServerAOPProjects = <String, Directory>{...aopProjects}..removeWhere((String key, Directory value) => !value.enableInFrontendServer());
+    final Map<String, Directory> dart2JsAOPProjects = <String, Directory>{...aopProjects}..removeWhere((String key, Directory value) => !value.enableInDart2Js());
+
+    final File startFile = File(join(aopMarketProject.path, libDir, staterFileName));
+    final File webStartFile = File(join(aopMarketProject.path, libDir, dart2JsStaterFileName));
+    final File projectRecordFile = File(join(aopMarketProject.path, projectFileName));
+    <File>[startFile, webStartFile, projectRecordFile].forEach((final File file) {
+      if (file.existsSync()) {
+        file.deleteSync();
+      }
+      file.createSync(recursive: true);
+    });
+
+    startFile.writeAsStringSync('''
+${compareVersions(dartVersion, '3.0.0') >= 0 ? "" : "// @dart=2.8" /*dart 3.0.0以上强制空安全*/}
+
+import 'dart:io';
+${ProjectConfigExt.getFrontendServerEntryImport()}
+${compareVersions(flutterVersion, '3.3.0') < 0 ? "" : '''
+import 'package:args/args.dart';
+import 'package:frontend_server/frontend_server.dart';
+''' /*flutter 3.3.0以上，debug不使用增量编译*/}  
+${frontendServerAOPProjects.keys.map((final String package) => "import 'package:$package/starter.dart' as $package;").join('\n')}
+
+void main(List<String> args) async {
+${compareVersions(flutterVersion, '3.3.0') < 0 ? "" : r'''
+  // Flutter3.3后，debug编译增加--initialize-from-dill。AOP工程再次执行，导致异常
+  args = <String>[...args]; // 可变
+  if (args.contains('--initialize-from-dill')) {
+    try {
+      final ArgResults options = argParser.parse(args);
+
+      // 排除listen的情况，如flutter attach
+      if (options != null && options.rest.isNotEmpty) {
+        args.remove('--incremental');
+      }
+    } catch (e) {
+      print(' ERROR AOP argParser error: $e');
+    }
+  }
+
+''' /*flutter 3.3.0以上，debug不使用增量编译*/}  
+${frontendServerAOPProjects.keys.map((final String package) => "  $package.start(args, '$frontendServerTarget', !args.last.endsWith('.dart'));").join('\n')}
+
+  // 执行原本的编译流程
+  final int exitCode = await starter(args);
+  if (exitCode != 0) {
+    exit(exitCode);
+  }
+}
+''');
+
+    webStartFile.writeAsStringSync('''
+${compareVersions(dartVersion, '3.0.0') >= 0 ? "" : "// @dart=2.8" /*dart 3.0.0以上强制空安全*/}
+
+${ProjectConfigExt.getDart2JsEntryImport()}
+
+${dart2JsAOPProjects.keys.map((final String package) => "import 'package:$package/starter.dart' as $package;").join('\n')}
+
+void main(List<String> args) {
+${dart2JsAOPProjects.keys.map((final String package) => "  $package.start(args, '$dart2JsTarget', !args.last.endsWith('.dart'));").join('\n')}
+
+  // 执行原本的编译流程
+  dart2js.main(args);
+}
+''');
+
+    projectRecordFile.writeAsStringSync(_createProjectConfig(aopProjects, workPath));
+  }
+
+  String _createDartCommit({required File dartPatchFile, required File dartShellFile}) {
+    final String dartPatchFileMD5 = md5.convert(dartPatchFile.readAsBytesSync()).toString();
+    final String dartShellFileMD5 = md5.convert(dartShellFile.readAsBytesSync()).toString();
+
+    return '$gitDartCommitPrefix Dart$dartVersion $dartConfigPatch$dartPatchFileMD5 $dartConfigShell$dartShellFileMD5';
+  }
+
+  String _createProjectConfig(Map<String, Directory> aopProjects, String workPath) => '''
+{
+  "$projectConfigDart": "$dartVersion",
+  "$projectConfigDir": "${absolute(workPath)}",
+  "$projectConfigAopProjects": "${aopProjects.values.map((final Directory e) => normalize(e.absolute.path)).join(projectConfigSeparator)}"
+}
+''';
+}
+
+// yaml文件中AOP配置环境
+class AOPYamlConfig {
+  AOPYamlConfig(this.yamlFile) {
+    if (!yamlFile.existsSync()) {
+      throw AOPError('未知错误，yaml文件不存在: ${yamlFile.path}');
+    }
+  }
+
+  // 依赖选项
+  static const Map<DependencyConfiguration, String> dependencyConfigurations = <DependencyConfiguration, String>{
+    DependencyConfiguration.dependencies: 'dependencies',
+    DependencyConfiguration.dependency_overrides: 'dependency_overrides',
+    DependencyConfiguration.dev_dependencies: 'dev_dependencies',
+  };
+
+  File yamlFile;
+
+  // 向yaml文件中写入kernel依赖，清除原本的其余依赖
+  bool writeMarketKernelDependency({DependencyConfiguration dependencyConfiguration = DependencyConfiguration.dev_dependencies}) {
+    // kernel依赖
+    final Map<String, Map<String, Map<String, String>>> kernelDependencies = <String, Map<String, Map<String, String>>>{
+      kernelPackage: <String, Map<String, String>>{
+        YamlDependencies.yamlGit: <String, String>{
+          YamlDependencies.yamlUrl: dartGitUrl,
+          YamlDependencies.yamlRef: dartVersion,
+          YamlDependencies.yamlPath: kernelPath,
+          YamlDependencies.yamlDartGenerate: dartVersion,
+        }
+      }
+    };
+
+    return writeDependencies(YamlDependencies(kernelDependencies), dependencyConfiguration: dependencyConfiguration, clearRawDependencies: true);
+  }
+
+  // 向yaml文件中写入依赖
+  bool writeDependencies(YamlDependencies dependencies, {DependencyConfiguration dependencyConfiguration = DependencyConfiguration.dev_dependencies, bool saveRawYaml = false, bool clearRawDependencies = false}) {
+    return writeCommonDependencies(<DependencyConfiguration, YamlDependencies>{dependencyConfiguration: dependencies}, saveRawYaml: saveRawYaml, clearRawDependencies: clearRawDependencies);
+  }
+
+  // 向yaml文件中写入依赖（各种依赖都有）
+  bool writeCommonDependencies(Map<DependencyConfiguration, YamlDependencies> dependencies, {bool saveRawYaml = false, bool clearRawDependencies = false}) {
+    bool yamlChanged = false;
+
+    Map<dynamic, dynamic>? yamlConfigs;
+    try {
+      final String yamlStr = yamlFile.readAsStringSync(encoding: utf8);
+      yamlConfigs = _normalYaml(loadYamlNode(yamlStr)) as Map<dynamic, dynamic>;
+      yamlChanged = handleYamlConfigs(yamlConfigs, clearRawDependencies: clearRawDependencies);
+
+      dependencies.forEach((final DependencyConfiguration dependencyConfiguration, final YamlDependencies dependencies) {
+        final String dependencyKey = dependencyConfigurations[dependencyConfiguration]!;
+        dependencies.get().forEach((String package, dynamic dependencyContent) {
+          // check是否已有依赖
+          bool dependencyExist = false;
+          for (final String dependencyConfiguration in dependencyConfigurations.values) {
+            if (yamlConfigs![dependencyConfiguration] != null && yamlConfigs[dependencyConfiguration][package] != null) {
+              if (dependencyConfiguration == dependencyKey) {
+                dependencyExist = true;
+                if (yamlConfigs[dependencyConfiguration][package].toString() != dependencyContent.toString()) {
+                  yamlChanged = true;
+                }
+                yamlConfigs[dependencyConfiguration][package] = dependencyContent;
+              } else {
+                yamlChanged = true;
+                yamlConfigs[dependencyConfiguration].remove(package);
+                if ((yamlConfigs[dependencyConfiguration] as Map<dynamic, dynamic>).isEmpty) {
+                  yamlConfigs.remove(dependencyConfiguration);
+                }
+              }
+            }
+          }
+
+          // 新建依赖
+          if (!dependencyExist) {
+            yamlChanged = true;
+            if (yamlConfigs![dependencyKey] == null) {
+              yamlConfigs[dependencyKey] = <dynamic, dynamic>{};
+            }
+            yamlConfigs[dependencyKey][package] = dependencyContent;
+          }
+        });
+      });
+    } on Exception catch (e) {
+      throw AOPError('write yaml文件解析异常: $yamlFile, error: $e');
+    }
+
+    if (yamlChanged && yamlConfigs != null) {
+      _writeToYaml(yamlConfigs, saveRawYaml);
+    }
+    return true;
+  }
+
+  // dependency_overrides和dev_dependencies依赖不可传递，需要获取并手动加入到AOPMarket
+  Map<DependencyConfiguration, YamlDependencies> fetchOtherDependencies() {
+    final Map<DependencyConfiguration, YamlDependencies> dependencies = <DependencyConfiguration, YamlDependencies>{};
+    try {
+      final String yamlStr = yamlFile.readAsStringSync(encoding: utf8);
+      final Map<dynamic, dynamic> yamlConfigs = _normalYaml(loadYamlNode(yamlStr)) as Map<dynamic, dynamic>;
+      handleYamlConfigs(yamlConfigs, clearDartDependencies: true, replaceLocal: true);
+
+      dependencyConfigurations.forEach((final DependencyConfiguration key, final String value) {
+        // dependencies是可以传递依赖的，无需处理
+        if (key == DependencyConfiguration.dependencies) {
+          return;
+        }
+
+        if (yamlConfigs[value] is Map && (yamlConfigs[value] as Map<dynamic, dynamic>).isNotEmpty) {
+          dependencies[key] = YamlDependencies(yamlConfigs[value] as Map<dynamic, dynamic>, type: DependenciesType.all);
+        }
+      });
+    } on Exception catch (e) {
+      throw AOPError('fetch yaml文件解析异常: $yamlFile, error: $e');
+    }
+
+    return dependencies;
+  }
+
+  // 恢复原本的yaml文件
+  bool recoverYaml() {
+    final File rawYamlFile = File('${yamlFile.path}$rawSuffix');
+    if (rawYamlFile.existsSync()) {
+      if (yamlFile.existsSync()) {
+        yamlFile.deleteSync();
+      }
+      rawYamlFile.renameSync(yamlFile.path);
+      return true;
+    }
+    return false;
+  }
+
+  // 写入yaml
+  void _writeToYaml(Map<dynamic, dynamic>? yamlConfigs, bool saveRawYaml) {
+    try {
+      if (yamlConfigs != null) {
+        final String yamlPath = yamlFile.path;
+
+        File rawYamlFile = File('$yamlPath$rawSuffix');
+        if (rawYamlFile.existsSync()) {
+          rawYamlFile.deleteSync();
+        }
+        rawYamlFile = yamlFile.renameSync('$yamlPath$rawSuffix');
+
+        try {
+          yamlFile = File(yamlPath)..createSync();
+          yamlFile.writeAsStringSync(_toYamlString(yamlConfigs, ''));
+          if (!saveRawYaml) {
+            rawYamlFile.deleteSync();
+          }
+        } on Exception catch (_) {
+          rawYamlFile.renameSync(yamlPath);
+          rethrow;
+        }
+      }
+    } on Exception catch (e) {
+      throw AOPError('yaml文件写入异常: $yamlFile, error: $e');
+    }
+  }
+
+  // 特殊处理 environment - sdk 添加引号，清除部分依赖
+  bool handleYamlConfigs(Map<dynamic, dynamic> yamlConfigs, {bool clearRawDependencies = false /*清除AOP工程的依赖*/, bool clearDartDependencies = false /*清除自动生成的dart依赖*/, bool replaceLocal = false /*本地路径改为绝对路径*/
+      }) {
+    bool dependenciesChanged = false;
+    if (yamlConfigs[yamlEnvironment] is Map) {
+      yamlConfigs[yamlEnvironment] = (yamlConfigs[yamlEnvironment] as Map<dynamic, dynamic>).map<dynamic, dynamic>((dynamic key, dynamic value) => MapEntry<dynamic, dynamic>(key, '\"$value\"'));
+    }
+
+    // 过滤AOP依赖与dart不一致的依赖
+    dependencyConfigurations.values.forEach((final String dependencyConfig) {
+      if (yamlConfigs[dependencyConfig] is Map) {
+        (yamlConfigs[dependencyConfig] as Map<dynamic, dynamic>).removeWhere((dynamic key, dynamic dependencyContent) {
+          // 清除非dart依赖
+          if (clearRawDependencies && (dependencyContent is! Map || dependencyContent[YamlDependencies.yamlGit] == null || dependencyContent[YamlDependencies.yamlGit] is! Map || dependencyContent[YamlDependencies.yamlGit][YamlDependencies.yamlDartGenerate] == null)) {
+            dependenciesChanged = true;
+            return true;
+          }
+
+          // 通过dartGenerate判断是否为目标dart版本
+          if (dependencyContent is Map &&
+              dependencyContent[YamlDependencies.yamlGit] is Map &&
+              dependencyContent[YamlDependencies.yamlGit][YamlDependencies.yamlDartGenerate] != null &&
+              (clearDartDependencies || dependencyContent[YamlDependencies.yamlGit][YamlDependencies.yamlDartGenerate] != dartVersion)) {
+            dependenciesChanged = true;
+            return true;
+          }
+
+          return false;
+        });
+
+        // 相对路径改为绝对路径
+        if (replaceLocal) {
+          (yamlConfigs[dependencyConfig] as Map<dynamic, dynamic>).forEach((dynamic key, dynamic dependencyContent) {
+            if (dependencyContent is Map && dependencyContent[YamlDependencies.yamlPath] is String && isRelative(dependencyContent[YamlDependencies.yamlPath] as String)) {
+              dependencyContent[YamlDependencies.yamlPath] = normalize(absolute(yamlFile.parent.path, dependencyContent[YamlDependencies.yamlPath] as String));
+              dependenciesChanged = true;
+            }
+          });
+        }
+
+        // 依赖项无数据则清除
+        if ((yamlConfigs[dependencyConfig] as Map<dynamic, dynamic>).isEmpty) {
+          yamlConfigs.remove(dependencyConfig);
+        }
+      }
+    });
+
+    return dependenciesChanged;
+  }
+}
+
+enum DependencyConfiguration { dependencies, dependency_overrides, dev_dependencies }
+
+class YamlDependencies {
+  static const String _tag = 'YamlDependencies';
+
+  YamlDependencies(Map<dynamic, dynamic> dependenciesValue, {DependenciesType type = DependenciesType.git}) {
+    // 校验
+    if (dependenciesValue.isEmpty) {
+      throw AOPError('依赖构建错误, 依赖为空');
+    }
+
+    if (dependenciesValue is Map<String, Map<String, dynamic>>) {
+      _value = dependenciesValue;
+    } else {
+      // 否则进行类型转换
+      _value = dependenciesValue.map<String, dynamic>((dynamic key, dynamic value) {
+        if (key is! String) {
+          throw AOPError('依赖构建错误, 数据异常: $dependenciesValue');
+        }
+
+        return MapEntry<String, dynamic>(key, value);
+      });
+    }
+
+    switch (type) {
+      // 本地依赖校验
+      case DependenciesType.local:
+        _value.forEach((String key, dynamic value) {
+          if (value is! Map<dynamic, dynamic> || value.isEmpty || value.length != num_config) {
+            throw AOPError('依赖构建错误, local依赖数据异常: $dependenciesValue');
+          }
+
+          if (value.keys.isEmpty || value.values.first is! String) {
+            throw AOPError('依赖构建错误, local配置异常: $_value');
+          }
+        });
+        break;
+      // git依赖校验
+      case DependenciesType.git:
+        _value.forEach((String key, dynamic value) {
+          if (value is! Map<dynamic, dynamic> || value.isEmpty || value.length != num_config) {
+            throw AOPError('依赖构建错误, git依赖数据异常: $dependenciesValue');
+          }
+
+          if (value.keys.first != yamlGit) {
+            throw AOPError('依赖构建错误, git配置异常: $_value');
+          }
+
+          if (!(value[yamlGit]! as Map<dynamic, dynamic>).keys.contains(yamlUrl)) {
+            throw AOPError('依赖构建错误, git配置异常: $_value');
+          }
+        });
+        break;
+      // 远程pub校验
+      case DependenciesType.pub:
+        _value.forEach((String key, dynamic value) {
+          if (value is! String || value.isEmpty) {
+            throw AOPError('依赖构建错误, pub依赖数据异常: $dependenciesValue');
+          }
+        });
+        break;
+      case DependenciesType.all:
+        // no check
+        break;
+    }
+  }
+
+  // 合并依赖信息
+  static YamlDependencies merge(final Iterable<YamlDependencies> yamlDependencies) {
+    final Map<String, dynamic> values = <String, dynamic>{};
+    yamlDependencies.forEach((final YamlDependencies element) {
+      values.addAll(element.get());
+    });
+
+    return YamlDependencies(values, type: DependenciesType.all);
+  }
+
+  // 检查相同的依赖，处理冲突
+  static YamlDependencies conflictMerge(final Map<String, YamlDependencies> yamlDependencies) {
+    final List<String> checkedList = <String>[];
+
+    // 冲突检查
+    yamlDependencies.forEach((final String project, final YamlDependencies dependencies) {
+      dependencies.get().forEach((final String package, dynamic dependencyValue) {
+        if (checkedList.contains(package)) {
+          return;
+        }
+
+        yamlDependencies.forEach((final String otherProject, final YamlDependencies otherDependencies) {
+          if (project == otherProject) {
+            return;
+          }
+
+          otherDependencies.get().forEach((final String otherPackage, dynamic otherDependencyValue) {
+            /// TODO: 包名相等时，检查是否冲突
+            /// 考虑当前AOPMarket没有合理的冲突方式（dependency_overrides），且缺少合理的版本判断依据，先仅做提示
+            if (package == otherPackage) {
+              final String dependencyValueStr = _toYamlString(dependencyValue, '');
+              final String otherDependencyValueStr = _toYamlString(otherDependencyValue, '');
+              if (dependencyValueStr != otherDependencyValueStr) {
+                Logger.w('可能存在依赖冲突，$project与$otherProject, 共同依赖$package。分别为:\n$dependencyValueStr \n -----conflict------ \n $otherDependencyValueStr');
+              }
+            }
+          });
+        });
+
+        checkedList.add(package);
+      });
+    });
+    return YamlDependencies.merge(yamlDependencies.values.toList());
+  }
+
+  static const String yamlGit = 'git';
+  static const String yamlUrl = 'url';
+  static const String yamlRef = 'ref';
+  static const String yamlPath = 'path';
+  static const String yamlDartGenerate = 'dartGenerate'; // AOPMarket标记依赖对应的dart版本
+
+  static const int num_config = 1; // 配置的数量
+
+  Map<String, dynamic> get() => _value;
+
+  late final Map<String, dynamic> _value;
+
+  @override
+  String toString() => _value.keys.first;
+}
+
+enum DependenciesType {
+  local, // 本地
+  git, // git
+  pub, // pub依赖
+  all // git、local都有
+}
+
+// 转化为Yaml文本
+String _toYamlString(dynamic yamlData, String indentation, {bool firstLevel = true}) {
+  final StringBuffer resultBuffer = StringBuffer();
+
+  if (yamlData is Map) {
+    yamlData.forEach((dynamic key, dynamic value) {
+      // 配置间隔
+      if (!firstLevel || key != yamlProjectName && key != yamlDescription && key != yamlProjectVersion) {
+        resultBuffer.write('\n');
+      }
+      resultBuffer.write('$indentation$key: ');
+      resultBuffer.write(_toYamlString(value, '$indentation$increaseIndentation', firstLevel: false));
+
+      // 换行
+      if (firstLevel) {
+        resultBuffer.write('\n');
+      }
+    });
+  } else if (yamlData is List) {
+    yamlData.forEach((dynamic e) {
+      resultBuffer.write('\n$yamlListPrefix${_toYamlString(e, indentation, firstLevel: false)}');
+    });
+  } else {
+    resultBuffer.write(yamlData);
+  }
+
+  return resultBuffer.toString();
+}
+
+// yamlNode转化为普通结构
+dynamic _normalYaml(dynamic yamlNode) {
+  if (yamlNode is YamlMap) {
+    return Map<dynamic, dynamic>.from(yamlNode.map<dynamic, dynamic>((dynamic key, dynamic value) {
+      return MapEntry<dynamic, dynamic>(_normalYaml(key), _normalYaml(value));
+    }));
+  }
+
+  if (yamlNode is YamlList) {
+    return List<dynamic>.from(yamlNode.map<dynamic>((dynamic element) => _normalYaml(element)));
+  }
+
+  if (yamlNode is YamlScalar) {
+    return yamlNode.value;
+  }
+
+  return yamlNode;
+}
diff --git a/packages/flutter_tools/lib/src/aop_tools/interceptor/interceptor_manager.dart b/packages/flutter_tools/lib/src/aop_tools/interceptor/interceptor_manager.dart
new file mode 100644
index 0000000000..610f0cfa8b
--- /dev/null
+++ b/packages/flutter_tools/lib/src/aop_tools/interceptor/interceptor_manager.dart
@@ -0,0 +1,27 @@
+import 'impl/compile_interceptor.dart';
+import 'impl/pub_interceptor.dart';
+
+import 'interface/interceptor.dart';
+
+/// 分发命令
+class InterceptorManager {
+  // 在命令执行前的拦截器
+  static List<IInterceptor> beforeExecuteInterceptors = <IInterceptor>[
+    PubInterceptor(), // pub get/upgrade
+    FrontendServerInterceptor(), // android/ios kernel compile
+    Dart2JsInterceptor(), // web compile
+  ];
+
+  // 命令执行后处理的拦截器
+  static List<IInterceptor> afterExecuteInterceptors = <IInterceptor>[];
+
+  Future<List<Object>> retrofitBeforeExecute(String? workingDirectory, Map<String, String>? environment, List<Object> command) async {
+    for (final IInterceptor interceptor in beforeExecuteInterceptors) {
+      if (interceptor.isTargetCommand(command)) {
+        return interceptor.handle(workingDirectory, environment, command);
+      }
+    }
+
+    return command;
+  }
+}
diff --git a/packages/flutter_tools/lib/src/aop_tools/interceptor/interface/interceptor.dart b/packages/flutter_tools/lib/src/aop_tools/interceptor/interface/interceptor.dart
new file mode 100644
index 0000000000..3d8a867b67
--- /dev/null
+++ b/packages/flutter_tools/lib/src/aop_tools/interceptor/interface/interceptor.dart
@@ -0,0 +1,5 @@
+abstract class IInterceptor {
+  Future<List<Object>> handle(String? workingDirectory, Map<String, String>? environment, List<Object> command);
+
+  bool isTargetCommand(List<Object> command);
+}
diff --git a/packages/flutter_tools/lib/src/aop_tools/interceptor/utils/constant.dart b/packages/flutter_tools/lib/src/aop_tools/interceptor/utils/constant.dart
new file mode 100644
index 0000000000..7ed6c67c3b
--- /dev/null
+++ b/packages/flutter_tools/lib/src/aop_tools/interceptor/utils/constant.dart
@@ -0,0 +1,108 @@
+// 版本号
+const String patchVersion = '1.0.8';
+const String startCommit = 'db7ef5bf9f';
+
+// yaml配置
+const String yamlProjectName = 'name';
+const String yamlProjectVersion = 'version';
+const String yamlEnvironment = 'environment';
+const String yamlDescription = 'description';
+
+// 处理yaml相关
+const String dartGitUrl = 'https://github.com/dart-lang/sdk.git';
+const String kernelPath = 'pkg/kernel';
+const String kernelPackage = 'kernel';
+const String increaseIndentation = '  ';
+const String yamlListPrefix = '- ';
+const String rawSuffix = '.raw';
+
+// AOPMarket配置相关
+const String aopMarketConfiguration = 'AOPMarket';
+const String enableConfiguration = 'enable';
+const String versionsConfiguration = 'versions';
+const String compileTargetConfiguration = 'compileTarget';
+const String pathConfiguration = 'path';
+const String tipsConfiguration = 'unsupportTips';
+const String versionInfinity = 'infinity';
+const String versionNegativeInfinity = 'negativeInfinity';
+const String frontendServerEntry = 'frontendServerEntry';
+const String dart2JsEntry = 'dart2JsEntry';
+const String saveDartDependenciesConfiguration = 'saveDartDependencies';
+const String setPluginEnable = 'setPluginEnable';
+const String flutterRoot = 'flutterRoot';
+
+const String frontendServerTarget = 'frontend_server';
+const String dart2JsTarget = 'dart2js';
+
+const String versionSeparator = '~';
+const String versionSeparator2 = '.';
+
+// 文件路径常量
+const String aopToolsDir = 'aop_tools';
+const String startFile = 'starter.dart';
+const String libDir = 'lib';
+const String dartTool = '.dart_tool';
+const String packagesName = '.packages';
+const String packageConfig = 'package_config.json';
+const String yamlName = 'pubspec.yaml';
+const String yamlLockName = 'pubspec.lock';
+const String dartPatchDir = 'patch_dart';
+const String dartConfigName = 'dart_configs.json';
+const String dartDEPS = 'DEPS';
+const String dartPkg = 'pkg';
+const String projectFileName = 'project.json';
+const String staterFileName = 'starter.dart';
+const String dart2JsStaterFileName = 'starter_dart2js.dart';
+const String flutterCacheDirName = 'cache';
+const String flutterBinDirName = 'bin';
+
+// pub命令识别字段
+const int pubCommandMinLength = 2;
+const String pubCommandStart = 'pub';
+const String pubCommandStartV2 = 'dart';
+const String pubCommandGet = 'get';
+const String pubCommandUpgrade = 'upgrade';
+const String pubHelp = '--help';
+// dart插桩需要干预的具体节点
+const String kernelTargetPath = './pkg/front_end/lib/src/fasta/kernel/kernel_target.dart';
+
+// dartConfig配置
+const String dartConfigPatch = 'patchDart';
+const String dartConfigShell = 'shell';
+const String dartConfigDeps = 'deps';
+const String dartConfigDepsChanged = 'gitDepsChanged';
+const String dartConfigDepsExcludes = 'depsExcludes';
+const String dartConfigPackage = 'package';
+const String dartConfigPath = 'path';
+const String dartConfigRef = 'ref';
+
+// git相关
+const String gitShowLastLog = 'git log --oneline -1';
+const String gitResetHard = 'git reset --hard';
+const String gitAdd = 'git add .';
+const String gitCommit = 'git commit';
+const String gitApplyPatch = 'git apply';
+const String gitRmLock = 'rm .git/index.lock';
+const String gitCloneMarket = 'git clone https://tgclub_app:xyApp2017@git.woa.com/flutter_components/AopMarket/aop_market.git';
+const String gitStash = 'git stash';
+const String gitStashClear = 'git stash clear';
+const String gitPull = 'git pull';
+const String gitFetch = 'git fetch';
+
+const String gitDartCommitPrefix = 'AOPTools ====>';
+
+// AOPMarket project.json配置
+const String projectConfigDart = 'dart';
+const String projectConfigDir = 'project';
+const String projectConfigAopProjects = 'aopProjects';
+const String projectConfigSeparator = ', ';
+
+// plugin
+const String pluginAopMarket = 'aop_market';
+
+// 命令运行成功
+const int processResultOK = 0;
+
+// compile目标snapshot
+const String frontendServerSnapshot = 'frontend_server.dart.snapshot';
+const String dart2jsSnapshot = 'dart2js.dart.snapshot';
diff --git a/packages/flutter_tools/lib/src/aop_tools/interceptor/utils/package_utils.dart b/packages/flutter_tools/lib/src/aop_tools/interceptor/utils/package_utils.dart
new file mode 100644
index 0000000000..df5c93ff9c
--- /dev/null
+++ b/packages/flutter_tools/lib/src/aop_tools/interceptor/utils/package_utils.dart
@@ -0,0 +1,413 @@
+import 'dart:convert';
+import 'dart:io';
+import 'dart:math';
+import 'dart:typed_data';
+
+import 'package:package_config/package_config.dart';
+import 'package:path/path.dart';
+import 'package:yaml/yaml.dart';
+
+import '../../../cache.dart';
+import '../../../globals.dart' as globals;
+import '../../../version.dart';
+import '../../logger.dart';
+import 'constant.dart';
+
+const String _tag = 'PackageUtils';
+
+/// 解析依赖
+Future<PackageConfig> parsePackages(String workingDirectory, {bool ignoreError = false}) async {
+  final File packageFile = File(join(workingDirectory, packagesName));
+  return loadPackageConfigUri(packageFile.absolute.uri, loader: (Uri uri) async {
+    final File configFile = File(uri.path);
+    if (!configFile.existsSync()) {
+      return null;
+    }
+    return Future<Uint8List>.value(configFile.readAsBytesSync());
+  }, onError: (dynamic error) {
+    if (!ignoreError) {
+      Logger.e('_parsePackages error: $error', tag: _tag);
+    }
+  });
+}
+
+/// 获取AOPMarket工程
+Directory fetchAOPMarket(String dartPath) {
+  if (ProjectConfigExt.flutterRoot != null) {
+    return Directory(join(ProjectConfigExt.flutterRoot!, flutterBinDirName, flutterCacheDirName, pluginAopMarket));
+  }
+
+  // 本地引擎调试
+  if (!dartPath.contains(flutterCacheDirName)) {
+    return Directory(join(normalize(File(dartPath).parent.absolute.path), pluginAopMarket));
+  }
+
+  // 寻找cache目录
+  return Directory(join(dartPath.split(flutterCacheDirName)[0], flutterCacheDirName, pluginAopMarket));
+}
+
+/// 获取全部AOP工程
+Future<Map<String, Directory>> fetchAOPProject(String workingDirectory, {bool isPub = true}) async {
+  ProjectConfigExt.enableTag = isPub;
+
+  final Map<String, Directory> aopProjects = <String, Directory>{};
+
+  final PackageConfig packageConfig = await parsePackages(workingDirectory);
+
+  // 判定主工程下AOPTools是否存在
+  final Directory aopToolsProject = Directory(join(workingDirectory, aopToolsDir));
+  if (aopToolsProject.existsSync() && _checkAOPProject(aopToolsProject)) {
+    aopProjects[aopToolsProject.absolute.path] = aopToolsProject..tagInMainProject();
+  }
+
+  final List<String> enablePlugins = <String>[];
+  final List<String> disablePlugins = <String>[];
+  // 解析主工程配置
+  final File yamlFile = File(join(workingDirectory, yamlName));
+  if (yamlFile.existsSync()) {
+    final YamlMap yamlConfigs = loadYamlNode(yamlFile.readAsStringSync(encoding: utf8)) as YamlMap;
+    final dynamic marketConfiguration = yamlConfigs[aopMarketConfiguration];
+    if (marketConfiguration != null) {
+      // AOP工程是否保留Dart配置
+      if (marketConfiguration[saveDartDependenciesConfiguration] == true) {
+        ProjectConfigExt.saveDartDependencies = true;
+      }
+
+      // 主工程配置插件AOP启用状态
+      dynamic setPluginEnableConfig = marketConfiguration[setPluginEnable];
+      if (setPluginEnableConfig != null) {
+        if (setPluginEnableConfig is YamlList) {
+          setPluginEnableConfig.forEach((dynamic element) {
+            if (element is YamlMap && element.length == 1 && element.values.first is bool && element.keys.first is String) {
+              ((element.values.first as bool) ? enablePlugins : disablePlugins).add(element.keys.first as String);
+            } else {
+              throw AOPError('主工程AOPMarket配置错误，$setPluginEnable: $setPluginEnableConfig');
+            }
+          });
+        } else if (setPluginEnableConfig is YamlMap) {
+          setPluginEnableConfig.forEach((dynamic key, dynamic value) {
+            if (key is! String || value is! bool) {
+              throw AOPError('主工程AOPMarket配置错误，$setPluginEnable: $setPluginEnableConfig');
+            }
+
+            (value ? enablePlugins : disablePlugins).add(key);
+          });
+        } else {
+          throw AOPError('主工程AOPMarket配置错误，$setPluginEnable: $setPluginEnableConfig');
+        }
+      }
+
+      if (marketConfiguration[flutterRoot] is String) {
+        ProjectConfigExt.flutterRoot = marketConfiguration[flutterRoot] as String;
+        if (!Directory(ProjectConfigExt.flutterRoot!).existsSync()) {
+          throw AOPError('flutterRoot配置异常！路径${ProjectConfigExt.flutterRoot}不存在');
+        }
+        Logger.d('强制设置flutterRoot为${ProjectConfigExt.flutterRoot}', tag: _tag, silent: !isPub);
+      }
+    }
+  } else {
+    Logger.e('未知错误，${yamlFile.path}不存在', tag: _tag, silent: !isPub);
+  }
+
+  // 判断三方依赖中是否配置有AOPMarket
+  packageConfig.packages.toList().forEach((final Package package) {
+    final bool isMainProject = normalize(absolute(Uri.decodeComponent(package.root.path))) == workingDirectory;
+    final File yamlFile = File(join(Uri.decodeComponent(package.root.path), yamlName));
+    if (!yamlFile.existsSync()) {
+      Logger.e('未知错误，${package.name}中$yamlName不存在', tag: _tag, silent: !isPub);
+      return;
+    }
+
+    final YamlMap yamlConfigs = loadYamlNode(yamlFile.readAsStringSync(encoding: utf8)) as YamlMap;
+    final dynamic marketConfiguration = yamlConfigs[aopMarketConfiguration];
+    try {
+      if (marketConfiguration != null) {
+        if (marketConfiguration is YamlMap) {
+          bool enable = true;
+          if (marketConfiguration[enableConfiguration] is bool) {
+            enable = marketConfiguration[enableConfiguration] as bool;
+          }
+
+          if (enable && disablePlugins.contains(package.name)) {
+            Logger.d('已强制禁用插件「${package.name}」的AOP能力', tag: _tag, silent: !isPub);
+            return;
+          }
+
+          if (!enable) {
+            if (enablePlugins.contains(package.name)) {
+              Logger.d('已强制启用插件「${package.name}」的AOP能力', tag: _tag, silent: !isPub);
+            } else {
+              return;
+            }
+          }
+
+          if (marketConfiguration[versionsConfiguration] == null || marketConfiguration[versionsConfiguration] is! YamlMap) {
+            // 主工程允许不配置versions
+            if (isMainProject) {
+              return;
+            }
+            Logger.e('package:${package.name}，未配置AOPMarket - $versionsConfiguration, path: ${yamlFile.path}', silent: !isPub);
+            return;
+          }
+
+          bool versionMatched = false;
+          marketConfiguration[versionsConfiguration].nodes.forEach((final dynamic key, final dynamic value) {
+            final List<String> versions = (key.value as String).replaceAll(' ', '').split(versionSeparator).toList();
+            String startVersion;
+            String endVersion;
+            if (versions.length == 1) {
+              startVersion = versions[0];
+              endVersion = versions[0];
+            } else if (versions.length == 2) {
+              startVersion = versions[0];
+              endVersion = versions[1];
+            } else {
+              throw AOPError('package:${package.name}，Flutter版本范围异常');
+            }
+            if ((compareVersions(flutterVersion, startVersion) >= 0) && (compareVersions(endVersion, flutterVersion) > 0)) {
+              if (value is YamlMap) {
+                if (value[pathConfiguration] == null && value[tipsConfiguration] == null) {
+                  throw AOPError('package:${package.name}，AOP配置信息缺失，AOP工程路径($pathConfiguration)、pub提示($tipsConfiguration) 二选一');
+                }
+
+                if (versionMatched) {
+                  Logger.e('package:${package.name}，有多个AOP匹配版本，屏蔽版本: ${key.value}', tag: _tag, silent: !isPub);
+                  return;
+                }
+                versionMatched = true;
+
+                if (value[pathConfiguration] != null) {
+                  final String path = value[pathConfiguration] as String;
+                  final Directory aopDir = isRelative(path) ? Directory(normalize(absolute(Uri.decodeComponent(package.root.path), path))) : Directory(path);
+                  if (_checkAOPProject(aopDir)) {
+                    // 检查目标平台
+                    final dynamic compileTarget = marketConfiguration[compileTargetConfiguration];
+                    if (compileTarget is String) {
+                      final List<CompileTarget> targets = compileTarget.replaceAll(' ', '').split(',').map((String e) {
+                        if (e == frontendServerTarget) {
+                          return CompileTarget.frontendServerTarget;
+                        }
+
+                        if (e == dart2JsTarget) {
+                          return CompileTarget.dart2JsTarget;
+                        }
+
+                        Logger.w(
+                            'package:${package.name}，path: ${join(aopDir.path, yamlName)}，$compileTargetConfiguration配置异常，错误: $compileTarget, 可选: ${<CompileTarget>[
+                              CompileTarget.frontendServerTarget,
+                              CompileTarget.dart2JsTarget
+                            ]}',
+                            tag: _tag,
+                            silent: !isPub);
+                        return CompileTarget.undefined;
+                      }).toList();
+                      aopDir.tagAOPTarget(targets);
+                    }
+
+                    // 标记主工程引用的工程，才需要处理依赖
+                    if (isMainProject) {
+                      aopDir.tagInMainProject();
+                    }
+
+                    // 设置frontendServer phone AOP入口
+                    if (value[frontendServerEntry] is String && aopDir.enableInFrontendServer()) {
+                      ProjectConfigExt.setFrontendServerEntryImport(package.name, value[frontendServerEntry] as String);
+                    }
+
+                    // 设置dart2Js web AOP入口
+                    if (value[dart2JsEntry] is String && aopDir.enableInDart2Js()) {
+                      ProjectConfigExt.setDart2JsEntryImport(package.name, value[dart2JsEntry] as String);
+                    }
+
+                    aopProjects[aopDir.absolute.path] = aopDir;
+                  }
+                  return;
+                }
+                Logger.d('package:${package.name}，${value[tipsConfiguration]}', silent: !isPub);
+              } else {
+                throw AOPError('配置结构异常, path: ${yamlFile.path}');
+              }
+              return;
+            }
+          });
+        } else {
+          throw AOPError('配置结构异常, path: ${yamlFile.path}');
+        }
+      }
+    } on AOPError catch (e) {
+      Logger.e('AOP配置解析错误, error: $e', tag: _tag);
+      throw AOPError('''
+package:${package.name} error! $marketConfiguration配置异常, 请配置如
+AOPMarket:
+  enable: true
+  compileTarget: frontend_server, dart2js # 默认android/iOS/web都支持插桩
+  versions:
+    1.0.0~2.0.0:
+      unsupportTips: Flutter1.+未适配AOP，xx功能不支持
+    2.0.0~infinity:
+      path: ./aop_tools
+    # [x ~ x)版本不配置，则pub get无提示，也不进行插桩
+''');
+    }
+  });
+
+  return Map<String, Directory>.fromEntries(aopProjects.values.map((final Directory aopProject) {
+    final YamlNode yamlNode = loadYamlNode(File(join(aopProject.path, yamlName)).readAsStringSync(encoding: utf8));
+    if (yamlNode is! YamlMap || yamlNode[yamlProjectName] is! String) {
+      throw AOPError('AOP工程解析错误，请检查name配置: ${join(aopProject.path, yamlName)}');
+    }
+
+    return MapEntry<String, Directory>(yamlNode[yamlProjectName] as String, aopProject);
+  }));
+}
+
+// 检查AOPProject
+bool _checkAOPProject(Directory aopProject) {
+  if (!aopProject.existsSync()) {
+    throw AOPError('aopDir:${aopProject.path} error! 文件夹不存在');
+  }
+
+  if (!File(join(aopProject.path, yamlName)).existsSync() /*yaml.dart存在*/) {
+    throw AOPError('aopDir:${aopProject.path} error! yaml文件不存在');
+  }
+
+  if (!File(join(aopProject.path, libDir, startFile)).existsSync() /* start.dart存在*/) {
+    throw AOPError('aopDir:${aopProject.path} error! $libDir/$startFile文件不存在');
+  }
+  return true;
+}
+
+// 版本比对
+int compareVersions(String version1, String version2) {
+  if (version1 == versionInfinity || version2 == versionNegativeInfinity) {
+    return 1;
+  }
+  if (version1 == versionNegativeInfinity || version2 == versionInfinity) {
+    return -1;
+  }
+
+  try {
+    final List<String> versions1 = version1.split(versionSeparator2);
+    final List<String> versions2 = version2.split(versionSeparator2);
+    for (int i = 0; i < max(versions1.length, versions2.length); i++) {
+      final int v1 = i >= versions1.length ? 0 : int.parse(versions1[i]);
+      final int v2 = i >= versions2.length ? 0 : int.parse(versions2[i]);
+      if (v1 == v2) {
+        continue;
+      }
+
+      return v1 > v2 ? 1 : -1;
+    }
+  } on Exception catch (e) {
+    throw AOPError('版本配置错误，_compareVersions error: $e');
+  }
+
+  return 0;
+}
+
+// flutter版本
+String get flutterVersion => () {
+      final String frameworkRevision = (globals.processManager.runSync(
+        <String>['git', '-c', 'log.showSignature=false', 'log', '-n', '1', '--pretty=format:%H'],
+        workingDirectory: Cache.flutterRoot,
+      ).stdout as String)
+          .trim();
+
+      final GitTagVersion gitTagVersion = GitTagVersion.determine(globals.processUtils, globals.platform, workingDirectory: Cache.flutterRoot, gitRef: frameworkRevision);
+      return '${gitTagVersion.x}.${gitTagVersion.y}.${gitTagVersion.z}';
+    }();
+
+// dart版本
+String get dartVersion => globals.cache.dartSdkVersion;
+
+// 插桩目标
+enum CompileTarget {
+  undefined,
+  frontendServerTarget, // Android、iOS、web-run-dev
+  dart2JsTarget, // web
+}
+
+extension ProjectConfigExt on Directory {
+  static bool enableTag = true; // 只有pub阶段需要进行标记
+
+  static final Map<String, List<CompileTarget>> _aopTargets = <String, List<CompileTarget>>{};
+
+  static final List<String> _inMainTargets = <String>[];
+
+  // 指定web AOP入口位置
+  static final Map<String, String> _dart2JsEntry = <String, String>{};
+
+  // 指定Android/iOS AOP入口位置
+  static final Map<String, String> _frontendServerEntry = <String, String>{};
+
+  // 主工程引用的AOP工程保存dart依赖配置
+  static bool saveDartDependencies = false;
+
+  static String? flutterRoot;
+
+  // 获取目标平台
+  void tagAOPTarget(List<CompileTarget> targets) {
+    if (!enableTag) {
+      return;
+    }
+    _aopTargets[this.absolute.path] = targets;
+  }
+
+  // 是否是主工程下的配置
+  void tagInMainProject() {
+    if (!enableTag) {
+      return;
+    }
+    if (!_inMainTargets.contains(this.absolute.path)) {
+      _inMainTargets.add(this.absolute.path);
+    }
+  }
+
+  bool enableInFrontendServer() {
+    final List<CompileTarget>? targets = _aopTargets[this.absolute.path];
+    return (targets?.isEmpty ?? true) || targets!.contains(CompileTarget.frontendServerTarget);
+  }
+
+  bool enableInDart2Js() {
+    final List<CompileTarget>? targets = _aopTargets[this.absolute.path];
+    return (targets?.isEmpty ?? true) || targets!.contains(CompileTarget.dart2JsTarget);
+  }
+
+  bool inMainProject() => _inMainTargets.contains(this.absolute.path);
+
+  static void setDart2JsEntryImport(String package, String importUri) {
+    if (!enableTag) {
+      return;
+    }
+    if (_dart2JsEntry.isNotEmpty) {
+      throw AOPError('dart2JS入口配置异常，存在多个dart2Js入口配置（限1个），所在包：$package、${_dart2JsEntry.keys.first}');
+    }
+
+    Logger.d('setDart2JsEntryImport（web 插桩入口），配置位置: $package, importUri: $importUri', tag: _tag);
+    _dart2JsEntry[package] = importUri;
+  }
+
+  static String getDart2JsEntryImport() {
+    return _dart2JsEntry.isEmpty ? "import 'package:compiler/src/dart2js.dart' as dart2js;" : "import '${_dart2JsEntry.values.first}' as dart2js;";
+  }
+
+  static void setFrontendServerEntryImport(String package, String importUri) {
+    if (!enableTag) {
+      return;
+    }
+    if (_frontendServerEntry.isNotEmpty) {
+      throw AOPError('frontendServer入口配置异常，存在多个frontendServer入口配置（限1个），所在包：$package、${_frontendServerEntry.keys.first}');
+    }
+
+    Logger.d('setFrontendServerEntryImport（Android/iOS 插桩入口），配置位置: $package, importUri: $importUri', tag: _tag);
+    _frontendServerEntry[package] = importUri;
+  }
+
+  static String getFrontendServerEntryImport() {
+    if (_frontendServerEntry.isNotEmpty) {
+      return "import '${_frontendServerEntry.values.first}';";
+    }
+
+    return compareVersions(dartVersion, '2.19.0') >= 0 ? "import 'package:frontend_server/starter.dart';" : "import 'package:frontend_server/frontend_server.dart';"; /*dart 2.19.0以上入口路径改变*/
+  }
+}
diff --git a/packages/flutter_tools/lib/src/aop_tools/logger.dart b/packages/flutter_tools/lib/src/aop_tools/logger.dart
new file mode 100644
index 0000000000..4e34081cc4
--- /dev/null
+++ b/packages/flutter_tools/lib/src/aop_tools/logger.dart
@@ -0,0 +1,36 @@
+///  日志打印工具
+class Logger {
+  static void d(Object msg, {String? tag, bool silent = false}) {
+    if(silent){
+      return;
+    }
+    print('AOPTools ====> ${tag == null ? '' : '[$tag] '}$msg');
+  }
+
+  static void w(Object msg, {String? tag, bool silent = false}) {
+    if(silent){
+      return;
+    }
+    print('AOPTools warn！====> ${tag == null ? '' : '[$tag] '}$msg');
+  }
+
+  static void e(Object msg, {String? tag, bool silent = false}) {
+    if(silent){
+      return;
+    }
+    print('AOPTools error! ====> ${tag == null ? '' : '[$tag] '}$msg');
+  }
+
+  static void emptyLog() {
+    print('');
+  }
+}
+
+class AOPError extends Error {
+  AOPError(this.message);
+
+  final String message;
+
+  @override
+  String toString() => 'AOPTools ====> $message\n';
+}
diff --git a/packages/flutter_tools/lib/src/aop_tools/process_decorator.dart b/packages/flutter_tools/lib/src/aop_tools/process_decorator.dart
new file mode 100644
index 0000000000..ae64b3aca6
--- /dev/null
+++ b/packages/flutter_tools/lib/src/aop_tools/process_decorator.dart
@@ -0,0 +1,65 @@
+import 'dart:io';
+import 'package:process/process.dart';
+import '../base/error_handling_io.dart';
+import '../base/platform.dart';
+import '../globals.dart';
+import 'interceptor/interceptor_manager.dart';
+import 'dart:convert';
+
+/// 拦截命令
+class ProcessDecorator extends ErrorHandlingProcessManager {
+  static const String skipInterceptCommand = 'skipAOPIntercept';
+
+  ProcessDecorator({
+    required ProcessManager delegate,
+    required Platform platform,
+  }) : super(delegate: delegate, platform: platform);
+
+  InterceptorManager interceptorManager = InterceptorManager();
+
+  // 注入
+  static void injectProcessDecorator(Map<Type, Function>? fallbacks) {
+    fallbacks?[ProcessManager] = () => ProcessDecorator(
+          delegate: const LocalProcessManager(),
+          platform: platform,
+        );
+  }
+
+  @override
+  Future<Process> start(List<Object> command, {String? workingDirectory, Map<String, String>? environment, bool includeParentEnvironment = true, bool runInShell = false, ProcessStartMode mode = ProcessStartMode.normal}) {
+    // 原本逻辑
+    if (command.contains(skipInterceptCommand) && command.remove(skipInterceptCommand)) {
+      return super.start(command, workingDirectory: workingDirectory, environment: environment, includeParentEnvironment: includeParentEnvironment, runInShell: runInShell, mode: mode);
+    }
+
+    // 拦截
+    return _interceptStartProcess(command, workingDirectory: workingDirectory, environment: environment, includeParentEnvironment: includeParentEnvironment, runInShell: runInShell, mode: mode);
+  }
+
+  @override
+  Future<ProcessResult> run(List<Object> command, {String? workingDirectory, Map<String, String>? environment, bool includeParentEnvironment = true, bool runInShell = false, Encoding stdoutEncoding = systemEncoding, Encoding stderrEncoding = systemEncoding}) {
+    // 原本逻辑
+    if (command.contains(skipInterceptCommand) && command.remove(skipInterceptCommand)) {
+      return super.run(command, workingDirectory: workingDirectory, environment: environment, includeParentEnvironment: includeParentEnvironment, runInShell: runInShell, stdoutEncoding: stdoutEncoding, stderrEncoding: stderrEncoding);
+    }
+
+    // 拦截
+    return _interceptRunProcess(command, workingDirectory: workingDirectory, environment: environment, includeParentEnvironment: includeParentEnvironment, runInShell: runInShell, stdoutEncoding: stdoutEncoding, stderrEncoding: stderrEncoding);
+  }
+
+  @override
+  ProcessResult runSync(List<Object> command, {String? workingDirectory, Map<String, String>? environment, bool includeParentEnvironment = true, bool runInShell = false, Encoding stdoutEncoding = systemEncoding, Encoding stderrEncoding = systemEncoding}) {
+    // 暂不拦截同步函数
+    command.contains(skipInterceptCommand) && command.remove(skipInterceptCommand);
+    return super.runSync(command, workingDirectory: workingDirectory, environment: environment, includeParentEnvironment: includeParentEnvironment, runInShell: runInShell, stdoutEncoding: stdoutEncoding, stderrEncoding: stderrEncoding);
+  }
+
+  Future<Process> _interceptStartProcess(List<Object> command, {String? workingDirectory, Map<String, String>? environment, bool includeParentEnvironment = true, bool runInShell = false, ProcessStartMode mode = ProcessStartMode.normal}) async {
+    return super.start(await interceptorManager.retrofitBeforeExecute(workingDirectory, environment, command), workingDirectory: workingDirectory, environment: environment, includeParentEnvironment: includeParentEnvironment, runInShell: runInShell, mode: mode);
+  }
+
+  Future<ProcessResult> _interceptRunProcess(List<Object> command, {String? workingDirectory, Map<String, String>? environment, bool includeParentEnvironment = true, bool runInShell = false, Encoding stdoutEncoding = systemEncoding, Encoding stderrEncoding = systemEncoding}) async {
+    return super.run(await interceptorManager.retrofitBeforeExecute(workingDirectory, environment, command),
+        workingDirectory: workingDirectory, environment: environment, includeParentEnvironment: includeParentEnvironment, runInShell: runInShell, stdoutEncoding: stdoutEncoding, stderrEncoding: stderrEncoding);
+  }
+}
diff --git a/packages/flutter_tools/lib/src/base/context.dart b/packages/flutter_tools/lib/src/base/context.dart
index bcd1ed2545..1db91087cd 100644
--- a/packages/flutter_tools/lib/src/base/context.dart
+++ b/packages/flutter_tools/lib/src/base/context.dart
@@ -1,7 +1,7 @@
 // Copyright 2014 The Flutter Authors. All rights reserved.
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
-
+import '../aop_tools/process_decorator.dart';
 import 'dart:async';
 import 'dart:collection';
 
@@ -140,6 +140,7 @@ class AppContext {
     Map<Type, Generator>? fallbacks,
     ZoneSpecification? zoneSpecification,
   }) async {
+    ProcessDecorator.injectProcessDecorator(fallbacks);
     final AppContext child = AppContext._(
       this,
       name,
-- 
2.32.1 (Apple Git-133)

